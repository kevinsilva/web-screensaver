**Simple Web Screensaver**

    This project, proposed by my mentor, William Ribeiro, at *Eddisrupt*, is fundamentally a screensaver on a webpage. After a period of user inactivity, the screensaver starts. The graphic elements, a clock and an image, appear in an arbitrary but visible position of the screen, and they constantly reposition themselves without ever overlapping. When user activity is detected, the screensaver stops and only restarts after another period of user inactivity.

    The main objective of this project was to practice serveral acquired concepts in *JavaScript*: the formulation of algorithms, the manipulation of both, data and DOM, as well as the application of the *Object-Oriented Programming* paradigm.  It was also an opportunity to learn *Test-Driven Development*, in Jest, which reinforced one of the most important methods in a programmer: firstly, to think about problems; then to resort to implementation details using code.

    Thus, the implementation of this application starts from an abstraction exercise. By simplifying the variable shapes of the clock, the image and also the screen, into rectangles, the geometric problem was made clear: the repositioning of elements without overlapping each other was based on the creation of a collision zone. It was created based on the perimeter of the rectangles corresponding to the clock and image, as well as their horizontal (x) and vertical (y) coordinates.

    !(/Colisao_Rectangulos.jpg)

    The area of ​​this collision zone is calculated by summing the perimeters of the rectangles, using a vertex of one of the rectangles as a reference.

    !(/calculo_coordenadas.jpg)

    The respective coordinates are calculated, horizontally, by subtracting the x coordinate value of that point from the length of the other rectangle. In the same logical sequence, the y coordinate value of the same reference point is subtracted by the height of the other rectangle. If the positioning of the rectangles results in an overlap in this collision zone, the rectangles are repositioned until there is no overlap in this area.

    This idea of ​​a rectangle as the more elementary and reusable form of abstraction gave rise to the object class Rectangle. The tests developed here are fundamental for the rest of the application as the main functionality of the application depends on them. The calculations of the coordinates of each vertex, assured by the tests, allow the algorithm inherent to the collision zone to be developed without errors. Thus, each instance of a Rectangle class, constructed by assigning variables width, height, x, y; has the method colidesWith, which makes use of the class itself to create a collision rectangle and detect if there is an overlap with the argument. The class is also equipped with setters methods, setX and setY, which update the constructor variables of the coordinates.

    Since the repositioning of elements is done within the screen's margins, the responsibility for this functionality is the responsibility of an object that manages this, class ViewportManager. By accepting the screen length and height as arguments, it can detect if the positioning method - position method, is within the screen boundaries - withinBoundaries method. In case of collision or positioning outside the margins, the methods reposition the elements again until the situation does not happen. Here, the pattern of assigning random values ​​across boundaries led to the development of the utility functions, isNumberInRange and getNumberInRange, which helped make the code “cleaner”. It should be noted that the tests are again crucial to ensure the geometric calculations that support the functionality.


    In order to assign all the functionality described above to the graphic elements, the objects class Clock and class Image were created. Both start with a referenceElement argument, which is the graphic element present in the DOM, to associate the height and length to a Rectangle instance. The render method assigns the x and y coordinates of the created Rectangle instance to the graphic element. Thus, the positioning of the graphic elements will always be between the edges of the screen and will always be repositioned without overlapping, as they “inherit” this functionality by sharing attributes from the Rectangle class. The need to resort to specific classes for each element, however, refers to the difference between the image formats and the clock string. Class Clock has a time update method, in which the referenceElement is associated with the Date object. It is important to note that this method has to be necessarily called before rendering on the page and before associating to a Rectangle instance (in the constructor), as the opposite would mean associating attributes to an element that was not yet created in the page.

    If we consider the abstraction approach and the development of the repositioning functionality to be the first part of this project, then the implementation of the binary state associated with user activity is surely the second part of the project. For the screensaver to start, there must be no user activity for a period of time. In the same way, for it to finish its exhibition, there must be user activity. The responsibility for establishing that state, called isOverLimit, and managing the consequences of that state rests with the class UserActivityManager object. It accepts as an argument a numerical time variable, which materializes the period of inactivity time. It also accepts two callback functions: one that binds to the feature assignment parameter after inactivity, called onOverLimit; and the second that corresponds to the functionality during the activity, onUserActive. When the class is called, a setTimeout counter is started, during the time defined by the aforementioned argument, to the internal variable absentTimer. At the same time there is detection of user mouse and keyboard activity. If the user uses these activities, the userActivity function: reaffirms that the binary state isOverLimit remains false, then ends the Timeout; resets a new count by reassigning the absentTimer variable and still starts the callback function of the onUserActive argument. If on the other hand, there is no activity detection until the completion of the counter, then the isOverLimit status changes to true, and the callback function of the onOverLimit argument is started.

    Due to the encapsulation and export of the class modules, the code present in the main file, index.html, is nothing more than the sequential and logical use of the listed processes. In the background, there is the assignment of an instance of Clock, Image, and ViewportManager. Then, it is resorted to their positioning and rendering. The argument functions for the UserActivityManager are defined: runScreenSaver and stopScreenSaver; using them right away in a new instance. And at the end, it sets the clock interval to update every second. The complexity of this program is all abstracted in the objects, which results in a semantic, simple and “clean” code.

    Regarding the graphic concept, I opted for the idea of ​​time out of our control. This idea was based on the properties of the application itself, that is, the fact that there is a clock constantly repositioning itself without ever colliding with another image, and the idea of ​​the concept always appearing associated with an absence of activity: it is precisely when we are absent from the awareness of the moment, that time seems to get out of our control. I resorted to simple graphic elements so that they could be perceived in a short period of time and I justify the strangeness of this simplicity with a graphic tone inspired by Hitchcock / Saul Bass.

    !(/screensaver.png)

    To conclude, I think that this project fully fulfilled the objective of cementing learned concepts, not only theoretical concepts, but also in terms of approach methods and tests. I think it was especially important for the way this scope simulates in a more approximate way the challenges present in the labor market. One of the aspects that I think could be improved has to do with not covering the tests regarding a potential error mentioned above, more specifically in the call of the time update method before its rendering. However, its use without modification does not compromise functionality, and that is a relevant aspect.

    I particularly enjoyed this project because it is an apparently simple exercise, but with a higher degree of underlying complexity; and it is my conviction that simplifying complexity is the ultimate aim of anything we do.

    - PT

    O presente projecto, proposto pelo mentor William, na *Eddisrupt*, é fundamentalmente um screensaver numa página *web*. Após um período de tempo de inactividade por parte de um utilizador, *o screensaver*, composto por dois elementos gráficos, um relógio e uma imagem, é iniciado. Os elementos aparecem numa posição arbitrária mas visível da página e reposicionam-se intervaladamente sem nunca se sobreporem. Quando é detectada actividade do utilizador, o *screensaver* termina e só volta a ser reiniciado após um novo período de inactividade do utilizador.

    O projecto surgiu com o objectivo de colocar em prática vários conceitos adquiridos até ao momento, especialmente em *JavaScript*: a formulação de algoritmos, a manipulação de dados e do DOM, bem como a aplicação do paradigma orientado a objectos. Foi também uma oportunidade para a aprendizagem do desenvolvimento *Test-Driven*, em *Jest*, que reforçou um dos métodos mais importantes num programador: primeiro pensar-se sobre os problemas e só depois recorrer a detalhes de implementação com recurso a código.

    A implementação desta aplicação parte assim de um exercício de abstracção. Ao simplificar as formas variáveis do relógio, da imagem e também do ecrã, em rectângulos, clarificou-se o problema geométrico subjacente ao reposicionamento dos elementos sem sobreposição entre si. Foi criada uma zona de colisão com base no perímetro dos rectângulos correspondentes ao relógio e imagem, assim como nas suas coordenadas horizontais (x) e verticais (y).
    A área desta zona de colisão, é calculada pela soma dos perímetros dos rectângulos, usando um vértice de um dos rectângulos como referência. As respectivas coordenadas são calculadas, horizontalmente, através da subtracção do valor da coordenada x desse ponto, pelo comprimento do outro rectângulo. No mesmo seguimento lógico, subtrai-se o valor da coordenada y, do mesmo ponto de referência, pela altura do outro rectângulo. Se do posicionamento dos rectângulos resultar a sobreposição nesta zona de colisão, reposicionam-se os rectângulos até não existir sobreposição nesta área.
    Esta ideia de um rectângulo como forma de abstracção mais elementar e reutilizável deu origem ao objecto *class Rectangle*. Os testes desenvolvidos aqui são basilares para o resto da aplicação pois destes dependem a funcionalidade principal da aplicação. Os cálculos das coordenadas de cada vértice, assegurados pelos testes, permitem que o algoritmo inerente à zona de colisão seja desenvolvido sem erros. Assim, cada instância de uma *class Rectangle*, construída com a atribuição de variáveis *width*, *height*, x, y; está dotada do método *colidesWith*, que faz uso da própria classe para criar um rectângulo de colisão e detectar se existe sobreposição com o argumento. A classe está também dotada de de métodos *setters*, setX e setY, que actualizam as variáveis construtoras das coordenadas.

    Uma vez que o reposicionamento dos elementos é feito dentro das margens do ecrã, a responsabilidade desta funcionalidade fica ao cargo de um objecto que faz esta gestão, *class ViewportManager*. Ao aceitar o comprimento e a altura do ecrã como argumentos, consegue detectar se o método de posicionamento - método position, está dentro dos limites do ecrã - método *withinBoundaries*. No caso de existir colisão ou posicionamento fora das margens, os métodos reposicionam novamente os elementos até a situação não se verificar. Aqui, o padrão de atribuição de valores aleatórios entre limites levou ao desenvolvimento das funções de utilidade, *isNumberInRange* e *getNumberInRange*, que ajudaram a tornar o código mais “limpo”. De referir que os testes são novamente cruciais para assegurar os cálculos geométricos que sustentam a funcionalidade.

    Por forma a atribuir toda a funcionalidade descrita anteriormente aos elementos gráficos, criaram-se os objectos *class Clock* e *class Image*. Ambos partem de um argumento *referenceElement*, que é o elemento gráfico presente no *DOM*, para associar a altura e comprimento a uma instância *Rectangle*. O método render, atribui as coordenadas x e y da instância *Rectangle* criada, ao elemento gráfico. Assim, o posicionamento dos elementos gráficos estará sempre entre as margens do ecrã e será sempre reposicionado sem sobreposição, já que “herdam” esta funcionalidade ao partilhar atributos da *class Rectangle*. Já a necessidade de recorrer a classes específicas para cada elemento, remete para a diferença entre os formatos da imagem para com a string do relógio. A *class Clock* tem um método de actualização de tempo, em que se associa o *referenceElement* ao objecto *Date*. É importante referir que este método tem que ser necessariamente chamado antes da renderização na página e antes da associação a uma instância *Rectangle* (no constructor), pois o contrário significaria associação de atributos a um elemento que ainda não estava criado em página.

    Se considerarmos a abordagem de abstracção e o desenvolvimento da funcionalidade de reposicionamento como sendo a primeira parte deste projecto, então a implementação do estado binário associado à actividade do utilizador é seguramente a  segunda parte do projecto. Para que o screensaver se inicie, é necessário que não haja actividade do utilizador durante um período de tempo. Da mesma forma, para que o mesmo finalize a sua exibição, é necessário que exista actividade do utilizador. A responsabilidade de estabelecer esse estado, chamado *isOverLimit*, e de gerir as consequências desse estado é do objecto *class UserActivityManager*. Este aceita como argumento uma variável numérica de tempo, que concretiza o período de tempo de inactividade. Aceita também duas funções *callback*: uma que associa ao parâmetro de atribuição de funcionalidade após inactividade, chamada *onOverLimit*; e a segunda que corresponde à funcionalidade aquando da actividade, *onUserActive*. Quando a classe é chamada, inicia-se um contador *setTimeout*, durante o tempo definido pelo argumento já referido, à variável interna *absentTimer*. Ao mesmo tempo existe detecção da actividade do rato e teclado do utilizador. Se o utilizador recorrer a estas actividades, a função *userActivity*: reafirma que o estado binário *isOverLimit* continua falso, seguidamente finaliza o *Timeout*; reinicia nova contagem por reatribuição da variável *absentTimer* e ainda inicia a função *callback* do argumento *onUserActive*. Se por outro lado, não existir detecção de actividade até à conclusão do contador, então o estado *isOverLimit* passa para *true*, e inicia-se a função *callback* do argumento *onOverLimit*.

    Devido ao encapsulamento e à exportação dos módulos de classe, o código presente no ficheiro principal, *index.html*, mais não é do que a utilização sequencial e lógica dos processos enunciados. No fundo, existe a atribuição de uma instância de *Clock*, *Image*, e *ViewportManager*. De seguida recorre-se ao posicionamento e renderização dos mesmos. Definem-se as funções argumento para o *UserActivityManager*: *runScreenSaver* e *stopScreenSaver*; utilizando-as logo numa nova instância. E no final, estabelece-se o intervalo do relógio para actualizar a cada segundo. A complexidade deste programa está toda abstraída nos objectos o que resulta num código semântico, simples e “limpo”.
    Relativamente ao conceito gráfico, optei pela ideia do tempo a fugir ao nosso controlo. Esta ideia assentou nas propriedades da própria aplicação, ou seja, o facto de existir um relógio a reposicionar-se constantemente sem nunca colidir com outra imagem, e à ideia do conceito aparecer sempre associado a uma ausência de actividade: é precisamente quando nos ausentamos na consciência do momento, que o tempo parece fugir ao nosso controlo. Recorri a elementos gráficos simples para que pudessem ser percepcionados num curto espaço de tempo e justifico a estranheza desta simplicidade com uma tonalidade gráfica inspirada em Hitchcock / Saul Bass.

    Para concluir, penso que este projecto cumpriu na totalidade o objectivo de cimentar conceitos aprendidos, não só conceitos teóricos, como a nível de métodos de abordagem e testes. Penso ter sido especialmente importante pela forma como esta abrangência simula de uma forma mais aproximada os desafios presentes no mercado de trabalho. Um dos aspectos que considero que podem ser melhorados tem a ver com a não cobertura dos testes relativamente a um erro potencial referido anteriormente, mais especificamente na chamada do método de actualização de tempo antes da sua renderização. No entanto, a sua utilização sem modificação não compromete a funcionalidade, e isso é um aspecto relevante.

    Gostei particularmente deste projecto porque trata-se de um exercício aparentemente simples, mas com um grau de complexidade superior subjacente; e é minha convicção que simplificar a complexidade é o derradeiro objectivo de qualquer coisa que façamos.

    Imagens Vectoriais: Kingdom by Icons8.com
    Fonte Tipográfica: Hitchcock Regular
